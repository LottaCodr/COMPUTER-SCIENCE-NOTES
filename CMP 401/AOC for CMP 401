CMP 401 AOC


Q1. Computers need their own language for various reasons. discuss any three reasons

Answer:
i. Precision and Unambiguity: The idea this computers need a language that is clear and concise in other for them to carry out a well structured information, which would lead to a properly accurate result, or better still, an expected result. Furthermore, this can be achieved by leveraging on the tools and techniques of computer languages which are essentially Syntax and Semantics. Each line of instruction has a specific meaning, this helps to eliminate any room for misinterpretation.

ii. Efficiency and Speed: The idea here is computer can't use human language to process information due to the fact that human process informaton in a narrative manner, while computer are excellent at parallel processes and lightning fast calculations.

iii. Abstraction and Complexity Management: The idea here is it would be overwhelming for humans to use human languages to carry out the tasks regarding the inner works of a computer, things like the interaction between the software and hardware of the computer. Now this is where the computer language comes in play, such that it hides the low level details, and instead provides the high-level concepts and functionalities of a computer. This helps us to focus more on what we want the computer to achieve as an end result.

Q2. Discuss object-oriented language stating the major principle behind it

Answer:
With the help of OOP, instead of focusing about procedures and instructions which is the ancient way we think about programs, we can rather now think about object, self-contained entities, and the code that makes them operate.

Lets feast:

Encapsulation:
In encapsulation, access to internal data is being controlled by methods. This ensures that there isnt unauthorized modification of data. Also it ensures modularizations, which means the codes act as modules, which facilitates reusability.
It helps to hide unneccessary processing information and focuses on the object public interface

Inheritance: 
This is a programming concept that promote the reuse of code, where objects can inherit the properties and attributes of other object or classes.

Polymorphism:
This entails method-overidding, in the concept where a subclass inherits the method of a parent class, then proceeds to change the behavour of the method.

Dynamic Dispath:
In this conceptualization, the datatype of the variable of the subclass is uniformly changed, regardless of whether the method was inherit from the parent class.

Upcasting and Downcasting:
Upcasting is achieved by assigning an object of the subclass to variable of the parentclass, or to the parent class variable..
Downcasting is achieved by converting the reference of the parent class to a subclass type. This concept is highly discouraged.

Abstraction:
The concept behind abstraction is highing irrelevant data from the public eye, and instead displaying the data/information of importance..
It's enables Generalization, invisibility of complex information.

Q3. Reasons to study programming languages

Answer:
- Problem Solving Skills & Critical Thinking Capabilities
- Personal Growth and Empowerment
- Career Opportunities & Growth
- Creativity & Innovation
- Understanding the Digital World


Q4. Who would you meet when it is time to define and standardise your programming language? Why does your language needs standardising and when is the appropriate time to go for it?

Answer:

- Language Developers
- Industry Representatives
- Technical Experts
- Academic Researchers
- Standardization Body Representatives (These include ISO *International Organization for Standardization* and ECMA *European Computer Manufacturers' Association* )

a. Why the language needs standardization
- Interoperability: This ensures that a code written in one environment will be run on others, facilitating collaboration and code reuse.

- Stability: Consistency and well-defined features helps defeat fragmentation and compatibility issues across different implementations.

- Clarity: A clear and concise standard encourages easier learning, understanding and development of tools and libraries for the language.

- Growth & Adoption: Standardization attracts more developers and users, fostering a larger community and sustainability to the long-term of the language.


b. When to go for standardization:
- When there exist an industry demand of the language, meaning the language is used to develop crucial application across diverse companies 
- When the community comes in agreement that the language needs to be standardized.
- When there is large and active user base of the language.
- When there is technical stability


Q5. Discuss the commonly used criteria for evaluating a programming language

Answer:
- Readability and writability: The syntax and stucture and avaliable documentation has to be clear and concise for newcomers who wants to use the programming language. Under the readability is the maintainability and expressiveness of the code.

- Performance and Efficiency: The execute speed of the code to run on targeted platform is a criteria that is used to evalute a programming language, which also includes the memory usage,concurrency and parallelism (meaning the support of handling multiple tasks or operations  simutaneously) of the programming language.

- Reliability and Robustness: The mechanism for catching and handling errors gracefully (this is callled Error Handling), and also preventing crashes and unexpect behaviour.Also the strictness to checking datatypes to help avoid errors and chances of vulnerabilities.. and Finally the security features of the programming language.

- Community and Ecosystem: This entails the avaliable of tools and libraries that has been created by the community around the programming language, including avaliability of quality documentations and tutorials, as well as the presence of community size, plays a vital role in the evaluation of a programming language.

- Platform Compatibility: This means the  platform and environment that is supported by this language. (Web, desktop, mobile)

- Suitability for your project: This is a judge on the language alignment with the project's specfic requirements, its domain and complexity.

- Personal Preference and experience: When considering a programming language, personal perference comes to play in the aspect of how well and easy it is for you to understand the syntax and style of other programming language.

Q6. Describe any one of the implementation methods. show diagrams

Let it be known, that there are 3 implementation method, which includes -  Compilation, Interpretation and Just-In-Time (J-I-T).

Answer:
1. Compilation: A compilar translate a source code file into an executable file which contains to machine code instructions, which is specific to a target platform. This executable file is then ran directly on the machine without the need of the compiler again.

The Diagram:
Source Code -> Compiler -> Executable File (Machine Code) -> Hardware

Here are the advantages of Compilation:
- Performance: Compiled programs are said to be run faster than interpreted programs because the  machine code which is converted from the source is pre-translated and optimized for the specfic platform.

- Resource Usage: runtime memory requirements and usage is reduced because after compilation, the compiler is nolonger needed, compared to interpreters.

- Standardization: The executable files (which contains the machine code instructions can be easily distributed and run on different machines with compatible platforms without the need of the compiler.

Now Disadvantages:
- Portability: Because the executable files are target platform specific, hence not all plaform will support its compatibility.
- Development Speed: Since there would need of making changes to the program, which hence requires recompilation and which therefore would be time-consuming with frequent modifications.
- Debugging: Here debugging can be a pain because the source code might not be directly linked to the executed machine code.


2. Interpretation: An interpreter reads and executes the source code line-by-line without generating a seperate executable file. Each line is translated into machine code on the go and executed immediately.

The Diagram:
Source Code -> Interpreter---{Machine Code}-> Hardware

The Advantages:
- Portability: They can run on differnt platforms as long as they have the interpreter for the specific language.
- Ease of Development: Modification and changes can be made on the source code and tested immediately, without the recompiling the entire code.
- Debugging: Errors can be easily identified and fix because of the line by line interpretation.

Now the disadvantages:
- Performance: Interpreters tends to be slower because they translate the code line by line on the go.
- Resource Usage: When  it comes to memory usage, interpreters use more because the have to store both the Machine Code and the Source Code.
- Debugging: This is a challenge when the interpreter may not have access to the machine code that is being executed.


3. Just-In-Time(JIT) Compilation: This is a hybrid for of translation, as it combines the performance of compiled code and the flexibility of interpretation, having the elements of the two methods of implementation. It does this compiling the frequently used codes to machine code at runtime, and the less frequently section are interpreted.

The Diagram:
Source Code --> JIT Compiler ---[Machine Code]--> Executable Code --> Hardware

The Advantages:
- Performance: Often faster than Interpreters while approaching the performance of compiled code for frequently used sections.
- Portability: Compiled code are specific to platform, but with JIT Compiler method, the overall approach would be portable across platforms.
- Development Speed: When compared to Compilation, it offers a quicker development cycle and yet provides performance benefits.

Now the Disadvantages:
- Complexity: This JIT Implementation method is more complex compared to traditional Compilation and Interpretation.
- Startup Time: The initial compilation at run time leads to longer startup times compared to pre-compiled executables. 

Q7. Using an example, differentiate between syntax and semantics

Lets use a simple sentence "The Dog barks" to digest the differences of Syntax and Semantics

Understanding "SYNTAX"
Syntax refers to the structure and the grammatical rules of the sentence. It the skeleton, the elements or blueprints of the sentences.

Just like the sentence "The Dog barks", syntax defines the order of words in the sentence. (Subject-verb-object), so if you change it to "The Bird Barks", it is still syntactically correct, but semantically wrong.

- below is a python code

# Syntactically correct code:
x = 10
y = 5
print(x + y)  # Output: 15

# Syntactically incorrect code (missing colon):
if x > y print("x is greater")

Understanding "SEMANTICS":
Now Semantics focuses on the meaning of the sentences. So if you change "The Dog Barks" to "Barks Dog The", it is semantically invalid.

- Below is another python code:
# Semantically meaningful code:
name = "Alice"
print("Hello, " + name + "!")  # Output: Hello, Alice!

# Semantically nonsensical code but syntactically correct:
age = "blue"
print("You are " + age + " years old.")  # Output: You are blue years old.

THE KEY DIFFERENCE
- Form vs Meaning: Syntax deals with form and structure, while semantics deals with meaning and intension
- Ambiguity: Syntactically correct sentences (or codes) can have many interpretations, while the semantics gives it a defined meaning.
- Context Dependency: Semantics helps with giving the proper context to the meaning of a sentence.

Q8. GIven the statement: int i = 2*count+17(a+b); , seperate the statement into its tokens and lexemes

Answer:
 int i = 2 * count +17 (a+b) ;
<keyword> <identifier> <operator> <Number> <operator> <identifier> <operator> <Number> <operator> <identifier> <operator> <identifier> <operator> <operator>

The hint here is:
all datatypes are keywords (int, string,...)
Operator are mathematical symbols (=+- ()...)
Semicolon marks the end of the statement, but still considered an operator
Number are all numerical values

Q9. Given the grammar for a small language as:
 <program> → begin <stmt_list> end
				<stmt_list> → <stmt>
				 | <stmt> ; <stmt_list>
				<stmt> → <var> = <expression>
				<var> → A | B | C
				<expression> → <var> + <var>
				| <var> – <var>
				| <var>

Q10. Describe every components of this grammar.

Answer:

The Grammar Symbol:
- <program>, <stmt_list>,<stmt>,<var> and <expression> are all non-terminal symbols representing different syntactic catergories (or parts of speech) in the language.

- begin, end, = , +, -, A, B, and C are terminal symbols representing specfic keywords, operators and variables respectively.

- The arrow →  denotes a production rule, showing that the non-terminal symbol can be expanded into sequence of other symbols.

The Grammar Rules:
- <program>: A program starts with the keyword Begins, after which it follows a list of statements, and finally closes with the keyword end.

- <stmt_list>: This denotes that it carries other single statements seperated with commas <stmt>.. This <stmt_list>means a list of statement.

- <stmt>: This symbol called statement involves giving a value to a variable, by using the assignment operator which is =, and and expression <expression>

- <var>: This symbol means variable, which can be A,B, or C
- <expression>: An expression is when 2 are more variables are engaged in an activity with one or more operators. eg <var> + <var> or <var> - <var>

Q11. Generate the grammar for A = B * ( A + C ) and provide its parse tree.

Answer:

<expr> -> <id> = <expr>; (This is for the entire assignment statement)
<expr> -> (<expr>) (This is for the parenthesized expression)
<expr> -> <expr> * <expr> (This is for the multiplication expression)
<expr> -> <expr> + <expr> (This is for the addition expression)
<expr> -> <id> (This is the Identifier)

Q12. Show that the statement: A = B + C * A is an ambiguous grammar

Answer:

<Personal Opinion>
First of all the statement saying " A = B + C * A is an ambiguous grammar" is totally incorrect on its own because it is not A = B + C * A is not even a grammar but rather an expression. Grammars define how to generate valid strings in a language while expressions are very specific instances of those strings.

Additionally, a grammar is said to be Ambiguous when a single string can have multiple valid parse trees due to the rule of the grammar that leads to confusion in interpretation. 

